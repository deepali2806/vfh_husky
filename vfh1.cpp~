#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <stdlib.h>
#include <geometry_msgs/Pose2D.h>
#include "sensor_msgs/LaserScan.h"
#include "std_msgs/String.h"
#include <string>
#include <math.h>
#include <nav_msgs/Odometry.h>      
#include "sensor_msgs/Imu.h"
#include <tf/transform_datatypes.h>
#include "tf/transform_listener.h"
#include <angles/angles.h>



float scan_array[270];
float curr_possition[1][2];
float goal_possition[1][2];
int result_direction[270];
int threshold=2;
void processLaserScan(const sensor_msgs::LaserScan::ConstPtr& scan){
    //Ranges is the unbounded array i.e. vector and it has size of 720
     	ROS_INFO("Printig....%lu", scan->ranges.size());

     	for(int i = 0 ; i < scan->ranges.size(); i++){
     		scan_array[i]=scan->ranges[i];
     		ROS_INFO("Value at angle %d is : %f", i%270, scan->ranges[i]);
     		
     	}
     	    std::cout<<"------------------------------------------------------------------\n";
    }


   //Initializing the positions and z axis orientation
   double x=0.0;
   double y=0.0;
   double theta=0.0;
   
void odomCallback(const nav_msgs :: Odometry::ConstPtr& odom){
    //rostopic show Odometry
	x=odom->pose.pose.position.x;
	y=odom->pose.pose.position.y;
	double quat_x=odom->pose.pose.orientation.x;
 	double quat_y=odom->pose.pose.orientation.y;
	double quat_z=odom->pose.pose.orientation.z;
	double quat_w=odom->pose.pose.orientation.w;

    tf::Quaternion q(quat_x, quat_y, quat_z, quat_w);       //Quaternion gives the rotation 
    tf::Matrix3x3 m(q);
    double roll, pitch, yaw;
    m.getRPY(roll, pitch, yaw);                             //Changing queternion to Euler which gives 3 values 
                                                            //yaw is rotation around z axis
    //std::cout << "Roll: " << roll << ", Pitch: " << pitch << ", Yaw: " << yaw << std::endl;
    theta=yaw;
    //theta=angles::normalize_angle_positive(yaw);
      std::cout << std::fixed;
    std::cout<<"Rotation around z axis is "<<theta<<"\n";
    std::cout<<"x coordinates "<<x<<"\n";
    std::cout<<"y coordinates "<<y<<"\n";
    std::cout<<"z coordinates "<<quat_z<<"\n";
    curr_possition[0][0]=x;
    curr_possition[0][1]=y;

	
}


int main(int argc, char **argv) {
    //Initializes ROS, and sets up a node
    ros::init(argc, argv, "random_husky_commands");
    ros::NodeHandle nh;
    ros::Subscriber scanSub;
    
    int final_direction;
    
    std::cout<<"enter the goal points x and y";
    std::cin>>goal_possition[0][0];
    std::cin>>goal_possition[0][1];


    //Ceates the publisher, and tells it to publish
    //to the husky_velocity_controller/cmd_vel topic, with a queue size of 100
    ros::Publisher pub=nh.advertise<geometry_msgs::Twist>("/husky_velocity_controller/cmd_vel", 100);

        

    ros::Subscriber sub = nh.subscribe("/odometry/filtered", 10, odomCallback);
    scanSub=nh.subscribe<sensor_msgs::LaserScan>("scan",10,processLaserScan);
    geometry_msgs::Point goal;              //rostopic show Odometry
    //say goal is (5,5)
    goal.x=5;
    goal.y=5;

    geometry_msgs::Twist deep;              ///cmd_vel

    //Sets up the random number generator
    srand(time(0));

    //Sets the loop to publish at a rate of 10Hz
    ros::Rate rate(10);
    ros::spinOnce();

      while(ros::ok()) {


         /*  double inc_x=goal.x-x;
            double inc_y=goal.y-y;
            
            
            double angle_to_goal=atan2(inc_y,inc_x);        //atan2 returns in radians and it is inverse tan.
            if (abs(angle_to_goal - theta) > 0.1){          //if the vehicle is not facing to goal then change angle
                deep.linear.x=0.0;
                deep.angular.z=0.3;
            }
            else{                                           //if vehicle is facing to goal then go straight and dont change angle
                deep.linear.x=0.5;
                deep.angular.z=0.0;
            }
            //Publish the message
            pub.publish(deep);
                   // ros::spin();
            //Delays until it is time to send another message
            rate.sleep();
 */
           ros::spinOnce();
           
           for(int i=0;i<270;i++)
           {
           if(scan_array[i]<threshold)
           {
          	 result_direction[i]=0;
           }
           else
           {
                 result_direction[i]=1;
           }
           
           int angle=atan((curr_possition[0][1]-goal_possition[0][1])/(curr_possition[0][0]-goal_possition[0][0]))*180/3.14;
           
           for(int i=0;i<20;i++)
           {
           if(result_direction[angle-i]==1)
           {
          		 final_direction=angle-i;
          		 break;
           }
           else if(result_direction[angle+i]==1)
           {
                      final_direction=angle+i;
                                		 break;
           }
           }
           }
           double angler=final_direction*3.14/180;
           
                           deep.linear.x=curr_possition[0][0]+0.5;
                           deep.linear.y=curr_possition[0][1]+0.5;
                           deep.angular.z=angler;

            pub.publish(deep);


        }

}
